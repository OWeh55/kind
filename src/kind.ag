#include <dirent.h>
#include <sys/stat.h>
#include <cstring>
#include <unistd.h>

#include <iostream>
#include <fstream>

#include <string>
#include <vector>
#include <set>

#include <algorithm>

#include "stringtools.h"
#include "Exception.h"

#include "DateTime.h"
#include "Strings.h"
#include "FileName.h"

#include "KindConfig.h"
#include "filetools.h"
#include "Lexer.h"
#include "rulecomp.h"

#include "expiretools.h"

/*AppGen
  %%  Beschreibung des Programmes:
  prog: archiving backup
  %% Beschreibung Parameter
  % symbolischerName, Art, Typ,   Variablenname, Erklärung, Default-Wert
  para: vault_or_group, required, string, vault, Vault to backup
  %% Beschreibung der Optionen
  % kurz-Option, lang-Option, Typ, Variablenname, Erklärung, Default-Wert

  opt: f, full, void, fullImage, Force full image == initial backup, false
  opt: c, masterconfig, string, masterConfig, Master config file, ""
  opt2: if not given or empty kind looks for
  opt2:   /etc/kind/master.conf
  opt2:   /ffp/etc/kind/master.conf
  opt: B, backup, void, doBackup, Backup, false
  opt: E, expire, void, doExpire, Expire, false
  opt: C, listconfig, void, listConfig, Show configuration, false
  opt2:   if none of backup, expire or listconfig is specified,
  opt2:   backup and expire is assumed.
  opt: D, dryrun, Void, dryRun, Dry run (no real backup), false
  opt: v, verbose, Void, verbose,  Verbose,  false
  opt: d, debug, Void, debug, Debug output of many data, false
  opt: q, quiet, Void, quiet, Be quiet - no messages, false
  opt: h, help, usage, ignored , This help
AppGen*/

using namespace std;

/*AppGen:Global*/

void createExpireFile(const string& image, const KindConfig& conf, string& rule);

Strings banks;

typedef pair<long int, long int> Sizes;
map<string, Sizes> sizes;

void verbosePrint(const string& text)
{
  if (verbose)
    cout << "  " << text << endl;
}

void debugPrint(const string& text)
{
  if (verbose)
    cout << "    " << text << endl;
}

void writeSizes(const string logSizeFile)
{
  if (!logSizeFile.empty())
    {
      Strings st;
      for (auto s : sizes)
	{
	  string h = s.first + " " + to_string(s.second.first) + " " + to_string(s.second.second);
	  st.push_back(h);
	}
      strings2File(st, logSizeFile);
    }
}

void readMasterConfig1(const string& fn, KindConfig& conf)
{
  verbosePrint("reading master config " + fn);
  conf.addFile(fn);
}

void readMasterConfig(const string& fn, KindConfig& conf)
{
  if (!fn.empty())  // master config given by user on commandline
    readMasterConfig1(fn, conf);
  else if (fileExists("/etc/kind/master.conf"))
    readMasterConfig1("/etc/kind/master.conf", conf);
  else if (fileExists("/ffp/etc/kind/master.conf"))
    readMasterConfig1("/ffp/etc/kind/master.conf", conf);
  else
    throw Exception("MasterConfig", "no file");
}

string findVault(const string& v)
{
  bool found = false;
  FileName fn;
  fn.setName(v);
  for (unsigned int i = 0; !found && i < banks.size(); ++i)
    {
      fn.setPath(banks[i]);
      if (dirExists(fn.getFileName()))
        found = true;
    }
  if (!found)
    throw Exception("find vault", v + " not found");
  verbosePrint("using vault " + fn.getFileName());
  return fn.getFileName();
}

void readVaultConfig(const string& vault, KindConfig& conf)
{
  string vaultpath = findVault(vault);
  const string& vaultConfigName = vaultpath + '/' + conf.getString("vaultConfigName");
  verbosePrint("reading vault config:");
  verbosePrint("  " + vaultConfigName);
  conf.addFile(vaultConfigName);
}

string getImageName(const KindConfig& conf)
{
  bool nonPortable = false;
  string res = conf.getString("imageName");
  for (unsigned int i = 0; !nonPortable && i < res.size(); ++i)
    {
      char c = res[i];
      if (!isalnum(c) && c != '.' && c != '_')
        nonPortable = true;
    }
  if (nonPortable)
    throw Exception("getImageName", "Invalid character in image name " + res);
  return res;
}

bool isValidImage(const string& imageName)
{
  return dirExists(imageName) &&
         !fileExists(imageName + "/error") &&
         dirExists(imageName + "/tree");
}

Strings findValidImages(const string& vaultpath, const KindConfig& conf)
{
  Strings imageList;
  debugPrint("searching images in " + vaultpath);
  dirList(vaultpath, imageList);

  Strings validImageList;
  for (unsigned int i = 0; i < imageList.size(); ++i)
    {
      FileName fn(imageList[i]);
      string imgname = getImageName(conf);
      int len = imgname.length();
      if (fn.getName().substr(0, len) == imgname)
        {
          debugPrint("Checking " + imageList[i]);
          if (isValidImage(imageList[i]))
            validImageList.push_back(imageList[i]);
        }
    }
  if (validImageList.empty())
    throw Exception("Find reference", "No reference found");
  sort(validImageList.begin(), validImageList.end());
  return validImageList;
}

void backupVault(const string& vault,
                 KindConfig conf /*Copy!*/ ,
                 const DateTime& imageTime,
                 bool fullImage)
{
  if (!quiet)
    cout << DateTime::now().getString('h') << ": Backup of vault " << vault << endl;
  try
    {
      sizes[vault].second = 0; // nothing backed up yet

      readVaultConfig(vault, conf);

      // where to store
      string vaultpath = findVault(vault);

      // image path
      string imageName = getImageName(conf);
      if (!imageName.empty())
        imageName += '-';
      string imageFullName =  vaultpath + "/" + imageName ;

      if (conf.getBool("longImageName"))
        imageFullName += imageTime.getString('m');
      else
        imageFullName += imageTime.getString('s');

      verbosePrint("backup to \"" + imageFullName + "\"");

      // find reference image
      string referenceImage;
      if (!fullImage)
        {
          Strings validImageList = findValidImages(vaultpath, conf);
          // last image is newest image
          referenceImage = validImageList.back();
        }

      // create image path
      if (!dryRun)
        if (mkdir(imageFullName.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) != 0)
          throw Exception("Create image", "failed to create " + imageFullName);

      // error message
      // we write an generic error message to mark backup as unsuccessful
      // will be deleted at successful end of rsync
      string errorfile = imageFullName + "/error";
      if (!dryRun)
        {
          ofstream error(errorfile);
          error << "failed" << endl;
          error.close();
        }

      // create source descriptor
      string host;
      if (conf.hasKey("host"))
        host = conf.getString("host");

      string server;
      if (conf.hasKey("server"))
        server = conf.getString("server");

      if (!host.empty() && !server.empty())
        throw Exception("backupVault", "Cannot have host and server");

      string path = conf.getString("path");
      if (path.empty())
        throw Exception("rsync", "empty source path");
      if (path.back() != '/')
        path += '/';

      string rsyncCmd = "rsync -vrltH --delete --stats -D --numeric-ids ";
      if (!conf.getBool("ignorePermission"))
        rsyncCmd += "-pgo";
      vector<string> rso = conf.getStrings("rsyncOption");
      for (const string& opt : rso)
        rsyncCmd += opt + " ";

      // excludes
      Strings excluded;

      if (conf.hasKey("exclude"))
        excluded += conf.getStrings("exclude");

      if (!host.empty())  // shell mode
        {
          // cout << "USING SHELLMODE '" << host << "'" << endl;
          string remoteShell = conf.getString("remoteShell");
          string userAtHost = conf.getString("user") + "@" +
                              conf.getString("host");
          string rshCommand = remoteShell;
          if (remoteShell.empty())
            rshCommand = "ssh";

          rshCommand += " " + userAtHost;

          string userExcludeCommand = conf.getString("userExcludeCommand");

          if (!userExcludeCommand.empty())
            {
              replacePlaceHolder(userExcludeCommand, "%path", path);
              string excludeCommand = rshCommand + " " + userExcludeCommand;

              verbosePrint("searching for exclusions (" + excludeCommand + ")");

              int rc;
              Strings excludedFiles = myPopen(excludeCommand, rc, debug);
              if (rc > 0)
                throw Exception("Find exludes", "Search for excludes failed");

              for (unsigned int i = 0; i < excludedFiles.size(); ++i)
                {
                  FileName fn(excludedFiles[i]);
                  excluded.push_back('/' + fn.getPath());
                  debugPrint("Excluding: " + excluded.back());
                }
            }

          string userExcludeFile = conf.getString("userExcludeFile");
          if (!userExcludeFile.empty())
            {
              userExcludeFile = path + userExcludeFile;
              string getExcludeFileCommand = rshCommand;
              getExcludeFileCommand += " \" if [ -f '" + userExcludeFile + "' ]; then ";
              getExcludeFileCommand += " cat '" + userExcludeFile + "' ; fi \"";
              // cout << getExcludeFileCommand << endl;
              int rc;
              Strings excludes2 = myPopen(getExcludeFileCommand, rc, debug);
              if (rc == 0)
                excluded += excludes2;
            }

          if (!dryRun)
            strings2File(excluded, imageFullName + "/exclude");

          // rsync image

          if (!remoteShell.empty())
            rsyncCmd += " -e \'" + remoteShell + "\' ";

          rsyncCmd += "--exclude-from=" + imageFullName + "/exclude ";
          if (!referenceImage.empty())
            rsyncCmd += "--link-dest=" + referenceImage + "/tree ";
          rsyncCmd += userAtHost + ":" + path + " ";
          rsyncCmd += imageFullName + "/tree";
        } // shell mode
      else
        {
          // cout << "USING SERVERMODE" << endl;

          if (!dryRun)
            strings2File(excluded, imageFullName + "/exclude");

          rsyncCmd += "--exclude-from=" + imageFullName + "/exclude ";
          if (!referenceImage.empty())
            rsyncCmd += "--link-dest=" + referenceImage + "/tree ";
          rsyncCmd += conf.getString("server") + "::" + path + " ";
          rsyncCmd += imageFullName + "/tree";
        }

      debugPrint("Action: " + rsyncCmd);

      vector<string> backupResult;
      if (!dryRun)
        {
          verbosePrint("syncing (" + rsyncCmd + ")");
          int rc;
          backupResult = myPopen(rsyncCmd, rc, debug, imageFullName + "/rsync-log");
          if (rc == 0 ||
              rc == 24 || // "no error" or "vanished source files" (ignored)
              rc == 6144) // workaround for wrong exit code ??!!
            {
              unlink(errorfile.c_str());
              string lastLink = vaultpath + "/last";
              unlink(lastLink.c_str());
              symlink(imageFullName.c_str(), lastLink.c_str());
              long int st = 0;
              long int sc = 0;
              for (auto bl : backupResult)
                {
                  if (bl.substr(0, 15) == "Total file size")
                    st = getNumber(bl);
                  else if (bl.substr(0, 27) == "Total transferred file size")
                    sc = getNumber(bl);
                }
              // sizes[vault] = pair<long int, long int>(st, sc);
              sizes[vault] = Sizes(st, sc);
              //  cout << vault << " " << st << " || " << sc << endl;
            }
          else
            throw Exception("Backup", "Failed to execute rsync (result: " + to_string(rc) + ")");
        }
      else
        cout << "Not executing " << rsyncCmd << endl;

      string rule;
      createExpireFile(imageFullName, conf, rule);
    }
  catch (Exception ex)
    {
      cerr << "Exception in vault " << vault << ": " << ex.what() << endl;
    }
}

void expireVault(const string& vault, KindConfig conf, DateTime now)
{
  if (!quiet)
    cout << DateTime::now().getString('h') << ": Expiring images in vault " << vault << endl;

  readVaultConfig(vault, conf);

  string vaultpath = findVault(vault);

  Strings dirlist; // list of subdirectories
  dirList(vaultpath, dirlist);

  Strings validImages;
  Strings invalidImages;
  string imgname = getImageName(conf);

  for (unsigned int i = 0; i < dirlist.size(); ++i)
    {
      FileName fn(dirlist[i]);
      if (startsWith(fn.getName(), imgname)) // dir is image ?
        {
          debugPrint(dirlist[i]);

          DateTime t = imageDate(dirlist[i]);

          if (t != now) // ignore just created image
            {
              if (!isValidImage(dirlist[i])) // invalid image?
                {
                  invalidImages.push_back(dirlist[i]);
                  debugPrint("- invalid image");
                }
              else
                {
                  validImages.push_back(dirlist[i]);
                  debugPrint("- valid image");
                }
            }
          else
            debugPrint("- current image - ignored");
        }
    }

  for (unsigned int i = 0; i < invalidImages.size(); ++i)
    {
      try
        {
          DateTime t = imageDate(invalidImages[i]);
          DateTime expireTime = t + stot(conf.getString("expireFailedImage"));
          if (debug)
            {
              cout << "image: " << t.getString('h') << "  expire: " << expireTime.getString('h') << endl;
              cout << " now: " << now.getString('h') << endl;
            }
          if (expireTime < now)
            {
              if (!quiet)
                cout << "  removing invalid image " << invalidImages[i] << endl;
              if (removeDir(invalidImages[i]) != 0)
                cout << "Error removing " <<  invalidImages[i] << endl;
            }
        }
      catch (Exception ex)
        {
          cerr << "Exception: " << ex.what() << endl;
        }
    }

  sort(validImages.begin(), validImages.end()); // lexicographical order == temporal order
  for (unsigned int i = 0;
       i < validImages.size() - 1; // never expire latest image
       ++i)
    {
      try
        {
          string imageName = validImages[i];
          DateTime imageTime = imageDate(imageName);
          string rule;
          DateTime expireTime = expireDate(imageName, conf, rule);

          if (debug)
            {
              cout << "image: " << imageTime.getString('h') << "  expire: " << expireTime.getString('h') << endl;
              cout << " now: " << now.getString('h') << endl;
            }
          if (now > expireTime)
            {
              if (!quiet)
                cout << "removing " << imageName << " rule=" << rule << endl;
              removeDir(imageName);
            }
        }
      catch (Exception ex)
        {
          cerr << "Exception: " << ex.what() << endl;
        }
    }
}

/*AppGen:Main*/
int main(int argc, char* argv[])
{
  /*AppGen:MainEnd*/

  int exitCode = 0;
  string lockFile;
  try
    {
      // handling of parameters and switches
      if (debug)        // debug implies verbose
        verbose = true;

      if (!doBackup && !doExpire && !listConfig)
        {
          doBackup = true;
          doExpire = true;
        }

      KindConfig conf;

      // default-values
      conf.add("imageName", "image");
      conf.add("vaultConfigName", "kind/vault.conf");
      conf.add("expireFailedImage", "3 days");
      conf.add("expireRule", "* * * * 1 month");
      conf.add("rsyncOption", ""); // no additional rsync option
      conf.add("remoteShell", "");
      conf.add("lockfile", "/var/lock/kind");
      conf.add("userExcludeFile", "nobackup.list");
      conf.add("userExcludeCommand",
               "find %path -type f -iname '*nobackup' -printf '%P\\\\n'");
      conf.add("logSize", "");

      if (listConfig)
        {
          cout << "builtin config" << endl;
          conf.print(".   ");
        }

      readMasterConfig(masterConfig, conf);

      banks = conf.getStrings("bank");
      if (banks.empty())
        throw Exception("read master configuration", "no banks defined");

      if (listConfig)
        {
          cout << "global config:" << endl;
          conf.print(".   ");
          readVaultConfig(vault, conf);
          cout << "vault config:" << endl;
          conf.print(".   ");
          exit(0);
        }

      lockFile = conf.getString("lockfile");
      createLock(lockFile);

      DateTime imageTime = DateTime::now();
      string logSizeFile = conf.getString("logSize");
      if (!logSizeFile.empty() && fileExists(logSizeFile))
        {
          vector<string> ss;
          file2Strings(logSizeFile, ss);
          for (auto s : ss)
            {
              unsigned int i = 0;
              string v = getWord(s, i);
              long int s1 = getLongInt(s, i);
              long int s2 = getLongInt(s, i);
              sizes[v] = Sizes(s1, s2);
            }
        }

      vector<string> vaults;
      string groupname = "group_" + vault;
      if (conf.hasKey(groupname))
        vaults = conf.getStrings(groupname);
      else
        vaults.push_back(vault);

      if (doBackup)
        for (unsigned int i = 0; i < vaults.size(); ++i)
          {
            backupVault(vaults[i], conf, imageTime, fullImage);
	    writeSizes(logSizeFile);
          }

      if (doExpire)
        for (unsigned int i = 0; i < vaults.size(); ++i)
          expireVault(vaults[i], conf, imageTime);

      if (!quiet)
        cout << DateTime::now().getString('h') << ": finished" << endl;

    }
  catch (const Exception& ex)
    {
      cerr << "Exception: " << ex.what() << endl;
      exitCode = 1;
    }
  catch (const char* msg)
    {
      cerr << "Exception(char*): " << msg << endl;
      exitCode = 1;
    }
  catch (const string& msg)
    {
      cerr << "Exception(string): " << msg << endl;
      exitCode = 1;
    }
  removeLock(lockFile);
  return exitCode;
}
